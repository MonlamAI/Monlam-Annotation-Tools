<!doctype html>
<html>

<head>
  <meta data-n-head="1" charset="utf-8">
  <meta data-n-head="1" name="viewport" content="width=device-width,initial-scale=1">
  <meta data-n-head="1" data-hid="description" name="description"
    content="Monlam Tools - ‡Ωò‡Ωº‡Ωì‡ºã‡Ω£‡Ωò‡ºã annotation tools for Tibetan language AI">
  <title>Monlam Tools</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon.png">
  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  <link rel="apple-touch-icon" sizes="180x180" href="/static/favicon.png">
  <link rel="preload" href="/static/_nuxt/08fba5f.js" as="script">
  <link rel="preload" href="/static/_nuxt/132fcbd.js" as="script">
  <link rel="preload" href="/static/_nuxt/50aa8ea.js" as="script">
  <link rel="preload" href="/static/_nuxt/bd0aa1f.js" as="script">
  <style>
    /* Monlam Tools Custom Branding */
    :root {
      --monlam-gold: #B8963E;
      --monlam-gold-dark: #9A7B32;
      --monlam-navy: #1a1a2e;
      --monlam-font: 'MonlamTBslim', 'Noto Sans Tibetan', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    .navbar.is-primary {
      background-color: var(--monlam-navy) !important;
    }

    .button.is-primary {
      background-color: var(--monlam-gold) !important;
      border-color: var(--monlam-gold) !important;
    }

    .button.is-primary:hover {
      background-color: var(--monlam-gold-dark) !important;
    }

    a.has-text-primary {
      color: var(--monlam-gold) !important;
    }

    .tag.is-primary {
      background-color: var(--monlam-gold) !important;
    }

    .menu-list a.is-active {
      background-color: var(--monlam-gold) !important;
    }

    .progress.is-primary::-webkit-progress-value {
      background-color: var(--monlam-gold) !important;
    }

    .tabs.is-toggle li.is-active a {
      background-color: var(--monlam-gold) !important;
      border-color: var(--monlam-gold) !important;
    }

    .pagination-link.is-current {
      background-color: var(--monlam-gold) !important;
      border-color: var(--monlam-gold) !important;
    }

    /* Hide GitHub button and link */
    a[href*="github.com"],
    a[href*="GITHUB"],
    button[class*="github"],
    .github-button {
      display: none !important;
    }

    /* ========================================
         MonlamTBslim FONT - Roboto deleted from build
         ======================================== */

    /* Primary MonlamTBslim font-face */
    @font-face {
      font-family: 'MonlamTBslim';
      src: local('MonlamTBslim'),
        url('/static/fonts/MonlamTBslim.woff2') format('woff2'),
        url('/static/fonts/MonlamTBslim.woff') format('woff'),
        url('/static/fonts/MonlamTBslim.ttf') format('truetype');
      font-weight: 100 900;
      font-style: normal;
      font-display: swap;
    }

    /* Roboto fallback - when Roboto is requested, use MonlamTBslim */
    @font-face {
      font-family: 'Roboto';
      src: local('MonlamTBslim'),
        url('/static/fonts/MonlamTBslim.woff2') format('woff2'),
        url('/static/fonts/MonlamTBslim.woff') format('woff'),
        url('/static/fonts/MonlamTBslim.ttf') format('truetype');
      font-weight: 100 900;
      font-style: normal;
      font-display: swap;
    }

    /* Apply MonlamTBslim everywhere */
    *,
    *::before,
    *::after {
      font-family: var(--monlam-font) !important;
    }

    /* Fix Tibetan vowel marks (‡Ω≤ ‡Ω¥) being cut off - need extra line-height */
    html,
    html body,
    html body *,
    .v-application,
    .v-application *,
    .v-btn,
    .v-list-item,
    .v-menu__content,
    .v-select__selection,
    .v-toolbar__title,
    .v-tab,
    label,
    span,
    p,
    div,
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      line-height: 1.8 !important;
    }

    /* Extra padding for menu items and buttons */
    .v-btn {
      padding-top: 4px !important;
      padding-bottom: 4px !important;
      min-height: 40px !important;
    }

    .v-list-item {
      min-height: 48px !important;
      padding-top: 8px !important;
      padding-bottom: 8px !important;
    }

    .v-tab {
      padding-top: 8px !important;
      padding-bottom: 8px !important;
    }

    .v-chip {
      height: auto !important;
      min-height: 32px !important;
      padding-top: 4px !important;
      padding-bottom: 4px !important;
    }

    .v-text-field input,
    .v-text-field textarea {
      padding-top: 8px !important;
      padding-bottom: 8px !important;
      line-height: 1.8 !important;
    }

    /* ========================================
         APPROVE/REJECT BUTTONS FOR REVIEWERS
         ======================================== */
    .monlam-review-container {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: flex-start;
      margin: 16px 0;
      padding: 12px;
      background: #f5f5f5;
      border-radius: 8px;
      width: 100%;
      flex-wrap: wrap;
    }

    .monlam-approve-btn {
      background-color: #4caf50 !important;
      color: white !important;
      padding: 10px 24px !important;
      border: none !important;
      border-radius: 6px !important;
      font-size: 16px !important;
      font-weight: 600 !important;
      cursor: pointer !important;
      transition: all 0.2s ease !important;
      display: flex !important;
      align-items: center !important;
      gap: 8px !important;
    }

    .monlam-approve-btn:hover {
      background-color: #388e3c !important;
      transform: scale(1.02) !important;
    }

    .monlam-reject-btn {
      background-color: #f44336 !important;
      color: white !important;
      padding: 10px 24px !important;
      border: none !important;
      border-radius: 6px !important;
      font-size: 16px !important;
      font-weight: 600 !important;
      cursor: pointer !important;
      transition: all 0.2s ease !important;
      display: flex !important;
      align-items: center !important;
      gap: 8px !important;
    }

    .monlam-reject-btn:hover {
      background-color: #c62828 !important;
      transform: scale(1.02) !important;
    }

    .monlam-review-status {
      font-size: 14px !important;
      padding: 6px 12px !important;
      border-radius: 4px !important;
      font-weight: 500 !important;
    }

    .monlam-status-approved {
      background-color: #e8f5e9 !important;
      color: #2e7d32 !important;
      border: 1px solid #4caf50 !important;
    }

    .monlam-status-rejected {
      background-color: #ffebee !important;
      color: #c62828 !important;
      border: 1px solid #f44336 !important;
    }

    .monlam-status-pending {
      background-color: #fff3e0 !important;
      color: #e65100 !important;
      border: 1px solid #ff9800 !important;
    }

    .monlam-review-notes {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      margin-top: 8px;
    }

    .monlam-review-notes:focus {
      outline: none;
      border-color: var(--monlam-gold);
    }
  </style>
</head>

<body>
  <div id="__nuxt">
    <style>
      #nuxt-loading {
        background: #fff;
        visibility: hidden;
        opacity: 0;
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        animation: nuxtLoadingIn 10s ease;
        -webkit-animation: nuxtLoadingIn 10s ease;
        animation-fill-mode: forwards;
        overflow: hidden
      }

      @keyframes nuxtLoadingIn {
        0% {
          visibility: hidden;
          opacity: 0
        }

        20% {
          visibility: visible;
          opacity: 0
        }

        100% {
          visibility: visible;
          opacity: 1
        }
      }

      @-webkit-keyframes nuxtLoadingIn {
        0% {
          visibility: hidden;
          opacity: 0
        }

        20% {
          visibility: visible;
          opacity: 0
        }

        100% {
          visibility: visible;
          opacity: 1
        }
      }

      #nuxt-loading>div,
      #nuxt-loading>div:after {
        border-radius: 50%;
        width: 5rem;
        height: 5rem
      }

      #nuxt-loading>div {
        font-size: 10px;
        position: relative;
        text-indent: -9999em;
        border: .5rem solid #f5f5f5;
        border-left: .5rem solid #B8963E;
        -webkit-transform: translateZ(0);
        -ms-transform: translateZ(0);
        transform: translateZ(0);
        -webkit-animation: nuxtLoading 1.1s infinite linear;
        animation: nuxtLoading 1.1s infinite linear
      }

      #nuxt-loading.error>div {
        border-left: .5rem solid #ff4500;
        animation-duration: 5s
      }

      @-webkit-keyframes nuxtLoading {
        0% {
          -webkit-transform: rotate(0);
          transform: rotate(0)
        }

        100% {
          -webkit-transform: rotate(360deg);
          transform: rotate(360deg)
        }
      }

      @keyframes nuxtLoading {
        0% {
          -webkit-transform: rotate(0);
          transform: rotate(0)
        }

        100% {
          -webkit-transform: rotate(360deg);
          transform: rotate(360deg)
        }
      }
    </style>
    <script>window.addEventListener("error", function () { var e = document.getElementById("nuxt-loading"); e && (e.className += " error") })</script>
    <div id="nuxt-loading" aria-live="polite" role="status">
      <div>Loading...</div>
    </div>
  </div>
  <script>window.__NUXT__ = { config: { _app: { basePath: "/", assetsPath: "/static/_nuxt/", cdnURL: null } } }</script>
  <script>
    // Tibetan translations for Monlam Tools (Doccano)
    const translations = {
      // Home page
      'Text Annotation for Humans': '‡Ωû‡Ω¥‡ºã‡Ωë‡ΩÇ‡ºã‡Ωñ‡æ±‡ºã‡Ω°‡Ω¥‡Ω£‡ºç',
      'Get Started': '‡Ω†‡ΩÇ‡Ωº‡ºã‡Ωñ‡Ω¢‡æ©‡Ωò‡Ω¶‡ºç',
      'GET STARTED': '‡Ω†‡ΩÇ‡Ωº‡ºã‡Ωñ‡Ω¢‡æ©‡Ωò‡Ω¶‡ºç',
      'The best features': '‡Ωë‡Ωò‡Ω≤‡ΩÇ‡Ω¶‡ºã‡Ωñ‡Ω¶‡Ω£‡ºã‡ΩÅ‡æ±‡Ωë‡ºã‡ΩÜ‡Ωº‡Ω¶‡ºç',
      'Team Collaboration': '‡Ωö‡Ωº‡ΩÇ‡Ω¶‡ºã‡Ωî‡Ω†‡Ω≤‡ºã‡Ωò‡Ωâ‡Ωò‡ºã‡Ω£‡Ω¶‡ºç',
      'Annotation with your team mates': '‡ΩÅ‡æ±‡Ωº‡Ωë‡ºã‡ΩÄ‡æ±‡Ω≤‡ºã‡Ω£‡Ω¶‡ºã‡Ω¢‡Ωº‡ΩÇ‡Ω¶‡ºã‡Ωë‡ΩÑ‡ºã‡Ωò‡Ωâ‡Ωò‡ºã‡Ωë‡Ω¥‡ºã‡Ωò‡ΩÜ‡Ωì‡ºã‡Ω†‡ΩÇ‡Ωº‡Ωë‡ºç',
      'Any Language': '‡Ω¶‡æê‡Ωë‡ºã‡Ω¢‡Ω≤‡ΩÇ‡Ω¶‡ºã‡ΩÇ‡ΩÑ‡ºã‡Ω°‡ΩÑ‡ºã‡ºç',
      'Annotation with any language': '‡Ω¶‡æê‡Ωë‡ºã‡Ω¢‡Ω≤‡ΩÇ‡Ω¶‡ºã‡ΩÇ‡ΩÑ‡ºã‡Ω°‡ΩÑ‡ºã‡Ω¢‡Ω¥‡ΩÑ‡ºã‡Ωñ‡Ω†‡Ω≤‡ºã‡Ωò‡ΩÜ‡Ωì‡ºã‡Ω†‡ΩÇ‡Ωº‡Ωë‡ºç',
      'Open Source': '‡Ω£‡Ω¶‡ºã‡Ω¶‡æ≥‡ºã‡Ωî‡Ωº‡ºç',
      'Annotation that is free and customizable': '‡Ω¢‡Ω≤‡Ωì‡ºã‡Ωò‡Ω∫‡Ωë‡ºã‡Ωë‡ΩÑ‡ºã‡Ω¢‡ΩÑ‡ºã‡Ωò‡Ωº‡Ω¶‡ºã‡Ωñ‡Ωü‡Ωº‡ºã‡Ωñ‡ΩÖ‡Ωº‡Ω¶‡ºã‡Ωñ‡æ±‡Ω∫‡Ωë‡ºã‡Ω¢‡Ω¥‡ΩÑ‡ºã‡Ωñ‡Ω†‡Ω≤‡ºã‡Ωò‡ΩÜ‡Ωì‡ºã‡Ω†‡ΩÇ‡Ωº‡Ωë‡ºç',
      'Realize your ideas quickly': '‡ΩÅ‡æ±‡Ωº‡Ωë‡ºã‡ΩÄ‡æ±‡Ω≤‡ºã‡Ωñ‡Ω¶‡Ωò‡ºã‡Ωñ‡æ≥‡Ωº‡ºã‡Ωò‡ΩÇ‡æ±‡Ωº‡ΩÇ‡Ω¶‡ºã‡Ωî‡Ωº‡Ω¢‡ºã‡Ωë‡ΩÑ‡Ωº‡Ω¶‡ºã‡Ω¶‡Ω¥‡ºã‡Ω¶‡æí‡æ≤‡Ω¥‡Ωñ‡ºç',
      'Try Demo': '‡Ωö‡Ωº‡Ωë‡ºã‡Ω£‡æü‡ºã‡Ωñ‡æ±‡Ω∫‡Ωë‡ºç',
      'TRY DEMO': '‡Ωö‡Ωº‡Ωë‡ºã‡Ω£‡æü‡ºã‡Ωñ‡æ±‡Ω∫‡Ωë‡ºç',

      // Navigation
      'Login': '‡Ωì‡ΩÑ‡ºã‡Ω†‡Ωõ‡Ω¥‡Ω£‡ºç',
      'LOGIN': '‡Ωì‡ΩÑ‡ºã‡Ω†‡Ωõ‡Ω¥‡Ω£‡ºç',
      'Sign Out': '‡Ωï‡æ±‡Ω≤‡Ω¢‡ºã‡Ω†‡Ωê‡Ωº‡Ωì‡ºç',
      'Projects': '‡Ω£‡Ω¶‡ºã‡ΩÇ‡Ωû‡Ω≤‡ºç',
      'PROJECTS': '‡Ω£‡Ω¶‡ºã‡ΩÇ‡Ωû‡Ω≤‡ºç',

      // Project home
      'Home': '‡Ωò‡Ωë‡Ω¥‡Ωì‡ºã‡ΩÑ‡Ωº‡Ω¶‡ºç',
      'Welcome to Doccano!': '‡Ω¶‡æê‡Ω¥‡ºã‡ΩÅ‡Ωò‡Ω¶‡ºã‡Ωñ‡Ωü‡ΩÑ‡ºã‡ºç',
      'Welcome to Monlam Tools!': '‡Ω¶‡æê‡Ω¥‡ºã‡ΩÅ‡Ωò‡Ω¶‡ºã‡Ωñ‡Ωü‡ΩÑ‡ºã‡ºç',
      'Import a dataset': '‡ΩÇ‡Ωû‡Ω≤‡ºã‡ΩÇ‡æ≤‡ΩÑ‡Ω¶‡ºã‡Ωì‡ΩÑ‡ºã‡Ω†‡Ωë‡æ≤‡Ω∫‡Ωì‡ºç',
      'Create labels for this project': '‡Ω£‡Ω¶‡ºã‡ΩÇ‡Ωû‡Ω≤‡ºã‡Ω†‡Ωë‡Ω≤‡Ω†‡Ω≤‡ºã‡ΩÜ‡Ω∫‡Ωë‡ºã‡ΩÅ‡ºã‡Ωñ‡æ±‡ΩÑ‡ºã‡ΩÇ‡Ω¶‡Ω¢‡ºã‡Ωñ‡Ωü‡Ωº‡ºç',
      'Add members for collaborative work': '‡Ωò‡Ωâ‡Ωò‡ºã‡Ω£‡Ω¶‡ºã‡ΩÄ‡æ±‡Ω≤‡ºã‡ΩÜ‡Ω∫‡Ωë‡ºã‡Ωö‡Ωº‡ΩÇ‡Ω¶‡ºã‡Ωò‡Ω≤‡ºã‡Ω¶‡æ£‡Ωº‡Ωì‡ºã‡Ωî‡ºç',
      'Define a guideline for the work': '‡Ω£‡Ω¶‡ºã‡ΩÄ‡Ω†‡Ω≤‡ºã‡Ω£‡Ωò‡ºã‡Ω¶‡æü‡Ωº‡Ωì‡ºã‡ΩÇ‡Ωè‡Ωì‡ºã‡Ω†‡ΩÅ‡Ω∫‡Ω£‡ºç',
      'Annotate the dataset': '‡ΩÇ‡Ωû‡Ω≤‡ºã‡ΩÇ‡æ≤‡ΩÑ‡Ω¶‡ºã‡Ω£‡ºã‡Ωò‡ΩÜ‡Ωì‡ºã‡Ω†‡ΩÇ‡Ωº‡Ωë‡ºç',
      'View statistics': '‡Ωö‡Ωë‡ºã‡ΩÇ‡Ωû‡Ω≤‡ºã‡Ω£‡æü‡ºã‡Ωñ‡ºç',
      'Export the dataset': '‡ΩÇ‡Ωû‡Ω≤‡ºã‡ΩÇ‡æ≤‡ΩÑ‡Ω¶‡ºã‡Ωï‡æ±‡Ω≤‡Ω¢‡ºã‡Ω†‡Ωë‡æ≤‡Ω∫‡Ωì‡ºç',

      // Common
      'Save': '‡Ωâ‡Ω¢‡ºã‡Ωö‡ΩÇ‡Ω¶‡ºç',
      'Edit': '‡Ω¢‡æ©‡Ωº‡Ωò‡ºã‡Ω¶‡æí‡æ≤‡Ω≤‡ΩÇ',
      'Create': '‡ΩÇ‡Ω¶‡Ω¢‡ºã‡Ωñ‡Ωü‡Ωº‡ºç',
      'Cancel': '‡Ω†‡Ωë‡Ωº‡Ω¢‡ºã‡Ωñ‡ºç',
      'Close': '‡Ω¶‡æí‡Ωº‡ºã‡Ω¢‡æí‡æ±‡ΩÇ',
      'Delete': '‡Ωñ‡Ω¶‡Ω¥‡Ωñ‡ºã‡Ωî‡ºç',
      'Search': '‡Ωñ‡Ωô‡Ω£‡ºã‡Ωû‡Ω≤‡Ωñ‡ºç',
      'Import': '‡Ωì‡ΩÑ‡ºã‡Ω†‡Ωë‡æ≤‡Ω∫‡Ωì‡ºç',
      'Export': '‡Ωï‡æ±‡Ω≤‡Ω¢‡ºã‡Ω†‡Ωë‡æ≤‡Ω∫‡Ωì‡ºç',
      'Add': '‡Ω¶‡æ£‡Ωº‡Ωì‡ºã‡Ωî‡ºç',
      'Upload': '‡Ω¶‡æê‡æ±‡Ω∫‡Ω£‡ºã‡Ω†‡Ωá‡Ω¥‡ΩÇ',
      'Yes': '‡Ω°‡Ω≤‡Ωì‡ºç',
      'No': '‡Ωò‡Ω≤‡Ωì‡ºç',
      'Loading...': '‡Ω¶‡æ£‡Ωì‡ºã‡Ωñ‡Ωû‡Ω≤‡Ωì‡ºã‡Ωî‡ºç...',
      'Loading... Please wait': '‡Ω¶‡æ£‡Ωì‡ºã‡Ωñ‡Ωû‡Ω≤‡Ωì‡ºã‡Ωî‡ºç ‡Ω¶‡æí‡Ω¥‡ΩÇ‡ºã‡Ω¢‡Ωº‡ΩÇ‡Ω¶‡ºç',

      // Labels/Annotation
      'Labels': '‡ΩÅ‡ºã‡Ωñ‡æ±‡ΩÑ‡ºã‡ºç',
      'Dataset': '‡ΩÇ‡Ωû‡Ω≤‡ºã‡ΩÇ‡æ≤‡ΩÑ‡Ω¶‡ºç',
      'Members': '‡Ωö‡Ωº‡ΩÇ‡Ω¶‡ºã‡Ωò‡Ω≤‡ºç',
      'Guideline': '‡Ω£‡Ωò‡ºã‡Ω¶‡æü‡Ωº‡Ωì‡ºç',
      'Statistics': '‡Ωö‡Ωë‡ºã‡ΩÇ‡Ωû‡Ω≤‡ºç',
      'Metrics': '‡Ωö‡Ωë‡ºã‡ΩÇ‡Ωû‡Ω≤‡ºç',
      'Settings': '‡Ω¶‡æí‡æ≤‡Ω≤‡ΩÇ‡ºã‡Ω†‡ΩÇ‡Ωº‡Ωë‡ºç',
      'Comments': '‡Ωò‡ΩÜ‡Ωì‡ºç',

      // Demo types
      'Named Entity Recognition': '‡Ωò‡Ω≤‡ΩÑ‡ºã‡Ωö‡Ω≤‡ΩÇ‡ºã‡Ωë‡Ωñ‡æ±‡Ω∫‡ºã‡Ω†‡Ωñ‡æ±‡Ω∫‡Ωë‡ºç',
      'Sentiment Analysis': '‡Ω¶‡Ω∫‡Ωò‡Ω¶‡ºã‡Ωö‡Ωº‡Ω¢‡ºã‡Ωë‡Ωñ‡æ±‡Ω∫‡ºã‡Ωû‡Ω≤‡Ωñ‡ºç',
      'Translation': '‡Ω°‡Ω≤‡ΩÇ‡ºã‡Ω¶‡æí‡æ±‡Ω¥‡Ω¢‡ºç',
      'Text to SQL': '‡Ω°‡Ω≤‡ºã‡ΩÇ‡Ω∫‡ºã‡Ωì‡Ω¶‡ºãSQL',
      'Intent Detection and Slot Filling': '‡Ωë‡Ωò‡Ω≤‡ΩÇ‡Ω¶‡ºã‡Ωñ‡Ω¶‡Ω£‡ºã‡Ω†‡Ωö‡Ωº‡Ω£‡ºã‡Ωû‡Ω≤‡Ωñ‡ºç',
      'Image Classification': '‡Ωî‡Ω¢‡ºã‡Ω¢‡Ω≤‡Ω¶‡ºã‡Ωë‡Ωñ‡æ±‡Ω∫‡ºã‡Ω†‡Ωñ‡æ±‡Ω∫‡Ωë‡ºç',
      'Image Captioning': '‡Ωî‡Ω¢‡ºã‡Ω¢‡Ω≤‡Ω¶‡ºã‡Ω†‡ΩÇ‡æ≤‡Ω∫‡Ω£‡ºã‡Ωñ‡Ω§‡Ωë‡ºç',
      'Object Detection': '‡Ωë‡ΩÑ‡Ωº‡Ω¶‡ºã‡Ωî‡Ωº‡ºã‡Ω†‡Ωö‡Ωº‡Ω£‡ºã‡Ωû‡Ω≤‡Ωñ‡ºç',
      'Polygon Segmentation': '‡Ωò‡Ωê‡Ω†‡ºã‡Ω¢‡Ω≤‡Ω¶‡ºã‡Ωë‡Ωñ‡æ±‡Ω∫‡ºã‡Ωñ‡Ωû‡ΩÇ',
      'Speech to Text': '‡Ω¶‡æê‡Ωë‡ºã‡ΩÜ‡ºã‡Ωì‡Ω¶‡ºã‡Ω°‡Ω≤‡ºã‡ΩÇ‡Ω∫‡ºç',

      // Project types
      'Text Classification': '‡Ω°‡Ω≤‡ºã‡ΩÇ‡Ω∫‡ºã‡Ωë‡Ωñ‡æ±‡Ω∫‡ºã‡Ω†‡Ωñ‡æ±‡Ω∫‡Ωë‡ºç',
      'Sequence Labeling': '‡Ωò‡Ωö‡Ωò‡Ω¶‡ºã‡Ω¢‡Ω≤‡Ω¶‡ºã‡ΩÅ‡ºã‡Ωñ‡æ±‡ΩÑ‡ºã‡ºç',
      'Sequence to sequence': '‡Ωò‡Ωö‡Ωò‡Ω¶‡ºã‡Ωì‡Ω¶‡ºã‡Ωò‡Ωö‡Ωò‡Ω¶‡ºç',

      // Doccano branding
      'doccano': 'Monlam Tools',
      'Doccano': 'Monlam Tools',
      'Monlam AI': 'Monlam Tools',

      // Copyright - fix year to 2026
      '¬© 2025 Monlam Tools': '¬© 2026 Monlam Tools',
      '¬© 2026 Monlam AI': '¬© 2026 Monlam Tools',

    };

    document.addEventListener('DOMContentLoaded', function () {
      // Update title
      document.title = 'Monlam Tools';

      // ========================================
      // Force Monlam favicon (override any Nuxt.js defaults)
      // ========================================
      function setFavicon() {
        // Remove existing favicons
        document.querySelectorAll('link[rel*="icon"]').forEach(function (link) {
          if (!link.href.includes('favicon.ico') && !link.href.includes('favicon.png')) {
            link.remove();
          }
        });

        // Ensure our favicon links exist
        const head = document.head;
        const existingIco = document.querySelector('link[href="/favicon.ico"]');
        if (!existingIco) {
          const ico = document.createElement('link');
          ico.rel = 'icon';
          ico.type = 'image/x-icon';
          ico.href = '/favicon.ico';
          head.appendChild(ico);
        }
      }
      setFavicon();

      function replaceText(element) {
        // Update title dynamically
        if (document.title.includes('doccano')) {
          document.title = 'Monlam Tools';
        }

        // Walk through all text nodes
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false);
        let node;
        while (node = walker.nextNode()) {
          let text = node.nodeValue;
          let changed = false;

          // Check each translation
          for (const [eng, tib] of Object.entries(translations)) {
            if (text.includes(eng)) {
              text = text.replace(new RegExp(eng.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), tib);
              changed = true;
            }
          }

          if (changed) {
            node.nodeValue = text;
          }
        }
      }

      // Observe DOM changes
      const observer = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
          if (mutation.type === 'childList') {
            mutation.addedNodes.forEach(function (node) {
              if (node.nodeType === Node.ELEMENT_NODE) {
                replaceText(node);
              }
            });
          }
        });
      });

      observer.observe(document.body, { childList: true, subtree: true });

      // Initial replacement
      replaceText(document.body);

      // Periodic check
      setInterval(function () {
        replaceText(document.body);
        // Remove GitHub buttons/links
        document.querySelectorAll('a[href*="github"], button').forEach(function (el) {
          if (el.textContent.toLowerCase().includes('github')) {
            el.style.display = 'none';
          }
        });
      }, 1000);

      // ========================================
      // Review Button Styling: Red O / Green Check
      // ========================================
      const CLOSE_PATH = "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z";
      const CHECK_PATH = "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z";
      const CIRCLE_PATH = "M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z";

      function styleReviewButtons() {
        document.querySelectorAll('.v-btn--icon .v-icon svg path').forEach(function (path) {
          const d = path.getAttribute('d');
          // X icon -> Red Circle
          if (d === CLOSE_PATH) {
            path.setAttribute('d', CIRCLE_PATH);
            path.style.fill = '#f44336';
          }
          // Check icon -> Green
          else if (d === CHECK_PATH) {
            path.style.fill = '#4caf50';
          }
        });
      }

      // Run periodically to catch dynamic updates
      setInterval(styleReviewButtons, 500);
      styleReviewButtons();

      // ========================================
      // FORCE MonlamTBslim font - override Vuetify's runtime Roboto injection
      // ========================================
      const MONLAM_FONT = "'MonlamTBslim', 'Noto Sans Tibetan', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";

      function forceMonlamFont() {
        // Override on html and body elements
        document.documentElement.style.setProperty('font-family', MONLAM_FONT, 'important');
        document.body.style.setProperty('font-family', MONLAM_FONT, 'important');

        // Override on v-application (Vuetify root)
        document.querySelectorAll('.v-application').forEach(function (el) {
          el.style.setProperty('font-family', MONLAM_FONT, 'important');
        });

        // Override all elements that Vuetify typically styles
        document.querySelectorAll('h1, h2, h3, h4, h5, h6, .display-1, .display-2, .headline, .title, .subtitle-1, .subtitle-2, .body-1, .body-2, .v-btn, .v-card, .v-list-item, .v-toolbar__title, .v-tab, span, p, div, label, input, textarea').forEach(function (el) {
          el.style.setProperty('font-family', MONLAM_FONT, 'important');
          el.style.setProperty('line-height', '1.8', 'important');
        });
      }

      // Run immediately and frequently to override Vuetify
      forceMonlamFont();
      setInterval(forceMonlamFont, 500);

      // Also run after page fully loads
      window.addEventListener('load', function () {
        forceMonlamFont();
        setTimeout(forceMonlamFont, 100);
        setTimeout(forceMonlamFont, 500);
        setTimeout(forceMonlamFont, 1000);
      });

      // ========================================
      // APPROVE/REJECT BUTTONS FOR REVIEWERS ONLY
      // ========================================

      // Lightweight API interceptor - captures example ID from Doccano's API calls
      // No DOM parsing, just intercepts fetch responses
      let currentExampleId = null;
      let exampleIdAttempts = 0;
      
      (function() {
        const originalFetch = window.fetch;
        window.fetch = async function(...args) {
          const response = await originalFetch.apply(this, args);
          
          // Intercept relevant API calls (multiple patterns)
          const url = typeof args[0] === 'string' ? args[0] : (args[0]?.url || '');
          
          // Check for example-related endpoints
          if (url.includes('/v1/projects/') && (
            url.includes('/examples/') || 
            url.includes('/next') ||
            url.includes('/texts') ||
            url.includes('/auto-labeling')
          )) {
            // Clone response to read without consuming
            try {
              const clone = response.clone();
              const contentType = clone.headers.get('content-type');
              if (contentType && contentType.includes('application/json')) {
                clone.json().then(data => {
                  // Extract example ID from various response formats
                  if (data) {
                    // Single example object: {id: 123, ...}
                    if (data.id && typeof data.id === 'number') {
                      currentExampleId = data.id;
                      exampleIdAttempts = 0; // Reset attempts on success
                      updateExampleIdInContainer(data.id);
                    } 
                    // List response: {results: [{id: 123}, ...]}
                    else if (data.results && Array.isArray(data.results) && data.results.length > 0) {
                      const firstExample = data.results[0];
                      if (firstExample && firstExample.id) {
                        currentExampleId = firstExample.id;
                        exampleIdAttempts = 0;
                        updateExampleIdInContainer(firstExample.id);
                      }
                    }
                    // Nested data: {data: {id: 123}}
                    else if (data.data && data.data.id) {
                      currentExampleId = data.data.id;
                      exampleIdAttempts = 0;
                      updateExampleIdInContainer(data.data.id);
                    }
                  }
                }).catch(() => {}); // Ignore JSON parse errors
              }
            } catch (e) {
              // Silently ignore clone errors
            }
          }
          
          return response;
        };
      })();
      
      // Helper to update container with example ID
      function updateExampleIdInContainer(id) {
        const container = document.querySelector('.monlam-review-container');
        if (container) {
          container.dataset.exampleId = id;
        }
        // Also store in window for global access
        window.monlamCurrentExampleId = id;
      }

      // Check if current user is an approver
      async function isApprover() {
        try {
          // Try to get user info from the page
          const userInfo = await fetch('/v1/me').then(r => r.ok ? r.json() : null).catch(() => null);
          if (userInfo && userInfo.username) {
            // Check if username contains 'approver' or check role
            return userInfo.username.toLowerCase().includes('approver') ||
              userInfo.is_staff === true ||
              (userInfo.groups && userInfo.groups.some(g => g.name && g.name.toLowerCase().includes('approver')));
          }

          // Fallback: check from page elements
          const userMenu = document.querySelector('[data-user]') || document.querySelector('.v-menu__content');
          if (userMenu) {
            const username = userMenu.textContent || '';
            return username.toLowerCase().includes('approver');
          }

          // Check URL or localStorage for user info
          const storedUser = localStorage.getItem('user') || sessionStorage.getItem('user');
          if (storedUser) {
            try {
              const user = JSON.parse(storedUser);
              return user.username && user.username.toLowerCase().includes('approver');
            } catch (e) { }
          }

          return false;
        } catch (e) {
          console.error('Error checking approver status:', e);
          return false;
        }
      }

      // Get project ID from URL
      function getProjectId() {
        const match = window.location.pathname.match(/\/projects\/(\d+)/);
        return match ? match[1] : null;
      }

      // Get CSRF token
      function getCSRFToken() {
        const cookie = document.cookie.split(';').find(c => c.trim().startsWith('csrftoken='));
        return cookie ? cookie.split('=')[1] : '';
      }

      // API call to approve/reject - uses backend API to get current example
      async function reviewExample(action, notes = '') {
        const projectId = getProjectId();

        if (!projectId) {
          showNotification('Cannot determine project ID.', 'error');
          return;
        }

        // Strategy 1: Use captured example ID from API interceptor
        let exampleId = currentExampleId || window.monlamCurrentExampleId;
        
        // Strategy 2: Check container dataset
        if (!exampleId) {
          const container = document.querySelector('.monlam-review-container');
          if (container && container.dataset.exampleId) {
            exampleId = container.dataset.exampleId;
          }
        }
        
        // Strategy 3: Try to get from Doccano's "next" endpoint (current example)
        if (!exampleId) {
          try {
            const nextResponse = await fetch(`/v1/projects/${projectId}/examples/next/`, {
              method: 'GET',
              headers: {
                'X-CSRFToken': getCSRFToken()
              },
              credentials: 'same-origin'
            });
            
            if (nextResponse.ok) {
              const nextData = await nextResponse.json();
              if (nextData && nextData.id) {
                exampleId = nextData.id;
                currentExampleId = exampleId;
                updateExampleIdInContainer(exampleId);
              }
            }
          } catch (e) {
            console.debug('Next endpoint failed:', e);
          }
        }
        
        // Strategy 4: Get first unconfirmed example from list
        if (!exampleId) {
          try {
            const examplesResponse = await fetch(`/v1/projects/${projectId}/examples/?limit=10`, {
              method: 'GET',
              headers: {
                'X-CSRFToken': getCSRFToken()
              },
              credentials: 'same-origin'
            });
            
            if (examplesResponse.ok) {
              const examplesData = await examplesResponse.json();
              if (examplesData.results && examplesData.results.length > 0) {
                // Find first unconfirmed example, or use first one
                const unconfirmed = examplesData.results.find(ex => !ex.is_confirmed) || examplesData.results[0];
                if (unconfirmed && unconfirmed.id) {
                  exampleId = unconfirmed.id;
                  currentExampleId = exampleId;
                  updateExampleIdInContainer(exampleId);
                }
              }
            }
          } catch (e) {
            console.debug('Examples list API failed:', e);
          }
        }
        
        // Strategy 5: Check URL pattern (last resort)
        if (!exampleId) {
          const urlMatch = window.location.pathname.match(/\/examples\/(\d+)/) ||
                          window.location.hash.match(/example[_-]?id[=:](\d+)/i);
          if (urlMatch) {
            exampleId = urlMatch[1];
            currentExampleId = exampleId;
            updateExampleIdInContainer(exampleId);
          }
        }

        if (!exampleId) {
          exampleIdAttempts++;
          if (exampleIdAttempts < 3) {
            // Retry after a short delay (maybe API hasn't loaded yet)
            setTimeout(() => reviewExample(action, notes), 500);
            return;
          }
          showNotification('Cannot find current example. Please navigate to an example and try again.', 'error');
          return;
        }
        
        // Reset attempts on success
        exampleIdAttempts = 0;

        return reviewExampleById(projectId, exampleId, action, notes);
      }

      async function reviewExampleById(projectId, exampleId, action, notes = '') {
        try {
          // Use Doccano's comment endpoint to record review
          const commentResponse = await fetch(`/v1/projects/${projectId}/comments`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': getCSRFToken()
            },
            credentials: 'same-origin',
            body: JSON.stringify({
              example: parseInt(exampleId),
              text: `[REVIEW:${action.toUpperCase()}] ${notes || (action === 'approve' ? 'Approved' : 'Rejected - Please revise')}`
            })
          });

          if (!commentResponse.ok) {
            const errorData = await commentResponse.text();
            throw new Error(`Comment API failed: ${errorData}`);
          }

          // For approval, also confirm the example state
          if (action === 'approve') {
            const stateResponse = await fetch(`/v1/projects/${projectId}/examples/${exampleId}/states`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCSRFToken()
              },
              credentials: 'same-origin'
            });

            if (!stateResponse.ok) {
              console.warn('State confirmation failed, but comment was saved');
            }
          } else {
            // For rejection, remove confirmation state
            const stateResponse = await fetch(`/v1/projects/${projectId}/examples/${exampleId}/states`, {
              method: 'DELETE',
              headers: {
                'X-CSRFToken': getCSRFToken()
              },
              credentials: 'same-origin'
            });
          }

          // Update UI
          updateReviewStatus(action, notes);
          showNotification(`${action === 'approve' ? '‚úÖ Approved' : '‚ùå Rejected'} successfully!`, action === 'approve' ? 'success' : 'warning');

          // Reload page after a short delay to show updated state
          setTimeout(() => {
            window.location.reload();
          }, 1500);

        } catch (error) {
          console.error('Review error:', error);
          showNotification(`Failed to save review: ${error.message}`, 'error');
        }
      }

      function showNotification(message, type) {
        const notif = document.createElement('div');
        notif.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 16px 24px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            z-index: 10000;
            animation: slideIn 0.3s ease;
            ${type === 'success' ? 'background: #4caf50;' : type === 'warning' ? 'background: #ff9800;' : 'background: #f44336;'}
          `;
        notif.textContent = message;
        document.body.appendChild(notif);

        setTimeout(() => notif.remove(), 3000);
      }

      function updateReviewStatus(action, notes) {
        const container = document.querySelector('.monlam-review-container');
        if (container) {
          const statusEl = container.querySelector('.monlam-review-status');
          if (statusEl) {
            statusEl.className = `monlam-review-status ${action === 'approve' ? 'monlam-status-approved' : 'monlam-status-rejected'}`;
            statusEl.textContent = action === 'approve' ? '‚úÖ Approved' : '‚ùå Rejected';
          }
        }
      }

      // Inject review buttons into annotation page (APPROVERS ONLY)
      let approverCheckDone = false;
      let isUserApprover = false;

      async function injectReviewButtons() {
        // Only inject on annotation pages
        if (!window.location.pathname.includes('/projects/')) return;
        if (window.location.pathname.includes('/dataset')) return;
        if (window.location.pathname.includes('/labels')) return;
        if (window.location.pathname.includes('/members')) return;
        if (window.location.pathname.includes('/settings')) return;

        // Check if buttons already exist
        if (document.querySelector('.monlam-review-container')) return;

        // Check user role (only once, cache result)
        if (!approverCheckDone) {
          isUserApprover = await isApprover();
          approverCheckDone = true;

          // Reset check when navigating to new page
          const currentPath = window.location.pathname;
          setTimeout(() => {
            if (window.location.pathname !== currentPath) {
              approverCheckDone = false;
            }
          }, 2000);
        }

        // Only show buttons for approvers
        if (!isUserApprover) {
          return;
        }

        // Find the textarea/text input area (transcription field)
        // Look for textarea elements used for transcription
        const textarea = document.querySelector('textarea.v-textarea__control') ||
          document.querySelector('textarea[placeholder*="text"]') ||
          document.querySelector('textarea[placeholder*="Text"]') ||
          document.querySelector('.v-textarea textarea') ||
          document.querySelector('textarea');
        
        // Find the parent container of the textarea
        let targetParent = null;
        if (textarea) {
          // Find the closest parent that's a card or form container
          targetParent = textarea.closest('.v-card') ||
                        textarea.closest('.v-textarea') ||
                        textarea.closest('.v-input') ||
                        textarea.closest('[class*="text"]') ||
                        textarea.parentElement;
        }
        
        // Fallback: find main content area
        if (!targetParent) {
          targetParent = document.querySelector('.v-main__wrap') ||
                        document.querySelector('.v-card') ||
                        document.querySelector('[class*="annotation"]');
        }
        
        if (!targetParent) return;

        // Create review container (example ID will be set when needed)
        const container = document.createElement('div');
        container.className = 'monlam-review-container';
        container.innerHTML = `
            <span class="monlam-review-status monlam-status-pending">üìã Pending Review</span>
            <input type="text" class="monlam-review-notes" placeholder="Review notes (optional)..." />
            <button class="monlam-approve-btn" onclick="window.monlamApprove()">
              <span>‚úÖ</span> Approve
            </button>
            <button class="monlam-reject-btn" onclick="window.monlamReject()">
              <span>‚ùå</span> Reject
            </button>
          `;

        // Insert right after the textarea or its parent container
        if (textarea && textarea.parentElement) {
          // Insert after the textarea's immediate parent (usually the v-input wrapper)
          const textareaWrapper = textarea.parentElement;
          if (textareaWrapper.nextSibling) {
            textareaWrapper.parentNode.insertBefore(container, textareaWrapper.nextSibling);
          } else {
            textareaWrapper.parentNode.appendChild(container);
          }
        } else if (targetParent) {
          // Insert at the end of the target parent
          targetParent.appendChild(container);
        }
      }

      // Global functions for button onclick
      window.monlamApprove = function () {
        const notes = document.querySelector('.monlam-review-notes')?.value || '';
        reviewExample('approve', notes);
      };

      window.monlamReject = function () {
        const notes = document.querySelector('.monlam-review-notes')?.value || '';
        reviewExample('reject', notes);
      };

      // Inject buttons periodically (for SPA navigation)
      // Check every 2 seconds, but only inject if approver
      setInterval(injectReviewButtons, 2000);

      // Initial injection after page load
      setTimeout(injectReviewButtons, 1000);
      setTimeout(injectReviewButtons, 3000);

    });
  </script>
  <script src="/static/_nuxt/08fba5f.js"></script>
  <script src="/static/_nuxt/132fcbd.js"></script>
  <script src="/static/_nuxt/50aa8ea.js"></script>
  <script src="/static/_nuxt/bd0aa1f.js"></script>
</body>

</html>